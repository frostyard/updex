---
phase: 05-integration-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - cmd/commands/install.go
  - cmd/commands/update.go
  - cmd/commands/remove.go
  - cmd/commands/list.go
  - cmd/commands/check.go
  - cmd/commands/daemon.go
  - cmd/commands/features.go
  - cmd/commands/vacuum.go
  - cmd/commands/pending.go
  - cmd/commands/discover.go
  - cmd/commands/components.go
autonomous: true

must_haves:
  truths:
    - "Error messages tell user what happened"
    - "Error messages suggest what to do next"
    - "Every command has Short, Long, and Example fields"
    - "Help text explains why and when, not just flag names"
  artifacts:
    - path: "cmd/commands/install.go"
      provides: "Polished install command"
      contains: "Example:"
    - path: "cmd/commands/update.go"
      provides: "Polished update command"
      contains: "Example:"
    - path: "cmd/commands/remove.go"
      provides: "Polished remove command"
      contains: "Example:"
  key_links:
    - from: "cmd/commands/*.go"
      to: "user experience"
      via: "cobra command fields"
      pattern: "(Short|Long|Example):"
---

<objective>
Audit and improve error messages and help text across all commands for clarity and actionability.

Purpose: Fulfills POLISH-01 (clear error messages) and POLISH-02 (comprehensive help text). Users should understand what went wrong and what to do about it. Help text should guide users effectively.
Output: All command files with improved error messages and comprehensive help text.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-integration-polish/05-RESEARCH.md

# Commands to audit
@cmd/commands/install.go
@cmd/commands/update.go
@cmd/commands/remove.go
@cmd/commands/list.go
@cmd/commands/check.go
@cmd/commands/daemon.go
@cmd/commands/features.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit and improve error messages</name>
  <files>
    cmd/commands/install.go
    cmd/commands/update.go
    cmd/commands/remove.go
    cmd/commands/daemon.go
    cmd/commands/features.go
  </files>
  <action>
Audit each command file for error messages and improve them following these patterns:

**Pattern (from 05-RESEARCH.md):**
```
Before: return fmt.Errorf("required flag --component is missing")
After:  return fmt.Errorf("missing --component flag; specify which extension to operate on")
```

**Guidelines:**
1. What happened? (clear description in user terms)
2. What can user do? (actionable suggestion)

**Specific improvements to make:**

install.go:
- "required flag --component is missing" -> "missing --component flag; specify which extension to install (e.g., --component docker)"

update.go:
- No error messages to improve (errors come from client)

remove.go:
- "required flag --component is missing" -> "missing --component flag; specify which extension to remove (e.g., --component docker)"

daemon.go (if has missing flag errors):
- Apply same pattern

features.go (if has errors):
- Apply same pattern

Do NOT add error types or complex error handling. Keep it simple - just improve the wording of existing fmt.Errorf calls.
  </action>
  <verify>`go build ./cmd/...` compiles successfully</verify>
  <done>Error messages are user-focused with actionable suggestions</done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive help text to all commands</name>
  <files>
    cmd/commands/install.go
    cmd/commands/update.go
    cmd/commands/remove.go
    cmd/commands/list.go
    cmd/commands/check.go
    cmd/commands/daemon.go
    cmd/commands/features.go
    cmd/commands/vacuum.go
    cmd/commands/pending.go
    cmd/commands/discover.go
    cmd/commands/components.go
  </files>
  <action>
Ensure every command has complete help text following this structure:

**Required fields:**
- Use: command signature with placeholders (e.g., "install URL")
- Short: One-line imperative description
- Long: Multi-paragraph explanation with WHEN to use
- Example: At least 2-3 real usage examples

**Template (from 05-RESEARCH.md):**
```go
Use:   "install URL",
Short: "Install an extension from a remote repository",
Long: `Install an extension from a remote repository.

Downloads the transfer file from the repository and places it in /etc/sysupdate.d/,
then downloads and installs the extension.

REQUIREMENTS:
  - Root privileges (run with sudo)
  - Network access to repository

WORKFLOW:
  1. Fetches extension list from URL
  2. Downloads .transfer configuration
  3. Downloads extension image`,
Example: `  # Install Docker extension from repository
  updex install https://repo.frostyard.org --component docker

  # Install without automatic refresh
  updex install https://repo.example.com --component myext --no-refresh`,
```

**Commands to audit/improve:**

1. install.go - Already has good structure, add REQUIREMENTS section
2. update.go - Already good, add more examples
3. remove.go - Already good, ensure Examples plural
4. list.go - Add Long and Example if missing
5. check.go - Add Long and Example if missing
6. daemon.go - Add Long and Example for subcommands
7. features.go - Add Long and Example for subcommands
8. vacuum.go - Add Long and Example
9. pending.go - Add Long and Example
10. discover.go - Add Long and Example
11. components.go - Add Long and Example

Focus on explaining WHY and WHEN to use each command, not just repeating flag names.
  </action>
  <verify>`updex --help` and `updex [command] --help` show comprehensive help text</verify>
  <done>All commands have Use, Short, Long, and Example fields with helpful content</done>
</task>

<task type="auto">
  <name>Task 3: Verify help text and error improvements</name>
  <files>cmd/commands/*.go</files>
  <action>
Build and manually test the CLI help output:

1. Build: `go build -o updex ./cmd/updex/`
2. Test each command's help:
   - `./updex --help`
   - `./updex install --help`
   - `./updex update --help`
   - `./updex remove --help`
   - `./updex daemon --help`
   - `./updex features --help`
   - `./updex list --help`
   - `./updex check --help`

3. Verify:
   - Each command shows Example section
   - Long description explains purpose, not just syntax
   - No duplicate information between Short and Long

4. Test error messages:
   - `./updex install` (without URL) - should show helpful error
   - `./updex remove` (without --component) - should show actionable message

If any help text is truncated or poorly formatted, adjust the Long field formatting.
  </action>
  <verify>`go build ./cmd/...` succeeds and help text renders correctly</verify>
  <done>All commands show polished help text and error messages</done>
</task>

</tasks>

<verification>
- `go build ./cmd/...` compiles successfully
- `updex install --help` shows Example section with 2+ examples
- `updex remove` (no args) shows actionable error message
- All 11 commands have Long and Example fields
</verification>

<success_criteria>
- POLISH-01 fulfilled: Error messages are clear and actionable
- POLISH-02 fulfilled: Help text is comprehensive and follows conventions
- Every command has Use, Short, Long, Example
- Error messages include suggestions for what to do
</success_criteria>

<output>
After completion, create `.planning/phases/05-integration-polish/05-02-SUMMARY.md`
</output>
