# Phase 5: Integration & Polish - Research

**Researched:** 2026-01-26
**Domain:** Go CLI integration testing, error messages, help text, shell completions
**Confidence:** HIGH

## Summary

This phase focuses on four requirements: integration tests (TEST-03), clear error messages (POLISH-01), comprehensive help text (POLISH-02), and shell completions (POLISH-03). The project is a Go CLI using cobra/spf13 enhanced by charmbracelet/fang, which already provides styled help output, styled error rendering, automatic version flags, and shell completion commands.

The existing test infrastructure is robust with 174+ tests across all packages, using table-driven tests, mock interfaces (SysextRunner, SystemctlRunner), httptest servers, and t.TempDir() for isolation. Tests already run without root using mocked interfaces. The integration testing task is to add workflow tests that span the install→update→remove lifecycle to validate end-to-end behavior.

For polish items: fang already handles error message styling and help text rendering. The main work is reviewing and improving the content (error wording, help text completeness) rather than implementing new error handling infrastructure. Shell completions are already generated by cobra's built-in `completion` command for bash, zsh, fish, and powershell - the work is to verify they function correctly and enhance with dynamic completions where beneficial.

**Primary recommendation:** Add integration tests covering complete workflows; audit and improve error message wording; ensure help text covers all flags/subcommands; test shell completions in actual shells.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `testing` | Go stdlib | Test framework | Built-in, already used extensively |
| `net/http/httptest` | Go stdlib | HTTP server mocking | Already in use in existing tests |
| `t.TempDir()` | Go stdlib | Filesystem isolation | Already used for all filesystem tests |
| `spf13/cobra` | v1.10.2 | CLI framework with completions | Already in use, handles completions |
| `charmbracelet/fang` | v0.4.4 | CLI enhancements | Already in use for styled output |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `internal/sysext.MockRunner` | (project) | Mock systemd-sysext | Already exists, use in integration tests |
| `internal/systemd.MockSystemctlRunner` | (project) | Mock systemctl | Already exists, extend for daemon tests |
| `internal/testutil` | (project) | HTTP test server helpers | Already exists, extend as needed |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Custom error types | github.com/pkg/errors | Adds dependency; fmt.Errorf with %w is sufficient |
| Manual completion testing | expect/pexpect | Complex; manual testing with real shells is simpler |
| Custom help rendering | github.com/olekukonko/tablewriter | fang already provides styled help |

**Installation:** None required - all tools already in use.

## Architecture Patterns

### Recommended Project Structure
```
updex/
├── updex/
│   ├── integration_test.go    # NEW: End-to-end workflow tests
│   ├── list_test.go           # Existing unit tests
│   ├── check_test.go
│   ├── update_test.go
│   ├── install_test.go
│   ├── remove_test.go
│   └── ...
├── internal/
│   ├── testutil/
│   │   ├── httpserver.go      # Existing HTTP mock helpers
│   │   └── fixtures.go        # NEW: Shared test fixtures (if needed)
│   └── ...
├── cmd/
│   └── commands/
│       └── ...                # Help text improvements here
└── scripts/
    └── test-completions.sh    # NEW: Manual shell completion tests
```

### Pattern 1: Workflow Integration Tests
**What:** Tests that exercise complete user workflows spanning multiple operations
**When to use:** Validating that install→update→remove sequences work correctly
**Example:**
```go
// Source: Adapted from existing project test patterns

func TestWorkflow_InstallUpdateRemove(t *testing.T) {
    // Setup: isolated filesystem and mock HTTP server
    configDir := t.TempDir()
    targetDir := t.TempDir()
    
    mockRunner := &sysext.MockRunner{}
    cleanup := sysext.SetRunner(mockRunner)
    defer cleanup()
    
    // HTTP server with multiple versions
    files := testutil.TestServerFiles{
        Files: map[string]string{
            "myext_1.0.0.raw": "hash1...",
            "myext_2.0.0.raw": "hash2...",
        },
        Content: map[string][]byte{
            "myext_1.0.0.raw": []byte("v1 content"),
            "myext_2.0.0.raw": []byte("v2 content"),
        },
    }
    server := testutil.NewTestServer(t, files)
    defer server.Close()
    
    // Create transfer config pointing to test server
    createTransferFile(t, configDir, "myext", server.URL)
    updateTransferTargetPath(t, configDir, targetDir)
    
    client := NewClient(ClientConfig{Definitions: configDir})
    
    // Step 1: Install (would normally fetch transfer from repo)
    // For this test, transfer already exists - test update flow
    
    // Step 2: Update - should install v2
    updateResult, err := client.Update(context.Background(), UpdateOptions{
        NoRefresh: true,
    })
    if err != nil {
        t.Fatalf("Update failed: %v", err)
    }
    if len(updateResult) != 1 || !updateResult[0].Downloaded {
        t.Errorf("Expected 1 downloaded result")
    }
    
    // Verify file exists
    if _, err := os.Stat(filepath.Join(targetDir, "myext_2.0.0.raw")); err != nil {
        t.Error("Extension file not created")
    }
    
    // Step 3: Check - should show as current
    versions, err := client.List(context.Background(), ListOptions{
        Component: "myext",
    })
    if err != nil {
        t.Fatalf("List failed: %v", err)
    }
    
    found := false
    for _, v := range versions {
        if v.Version == "2.0.0" && v.Current {
            found = true
        }
    }
    if !found {
        t.Error("v2.0.0 should be current")
    }
    
    // Step 4: Remove
    removeResult, err := client.Remove(context.Background(), "myext", RemoveOptions{
        NoRefresh: true,
    })
    if err != nil {
        t.Fatalf("Remove failed: %v", err)
    }
    if !removeResult.Success {
        t.Error("Remove should succeed")
    }
    
    // Verify file removed
    if _, err := os.Stat(filepath.Join(targetDir, "myext_2.0.0.raw")); !os.IsNotExist(err) {
        t.Error("Extension file should be removed")
    }
}
```

### Pattern 2: Error Message Audit Table
**What:** Systematic review of error messages with user-focused wording
**When to use:** POLISH-01 - ensuring all errors are clear and actionable
**Example:**
```go
// Before: Technical error
return fmt.Errorf("failed to fetch manifest: %w", err)

// After: User-focused error with action
return fmt.Errorf("could not download version list from %s: %w\n\nCheck your network connection or verify the repository URL is correct.", 
    sourceURL, err)

// Error message quality checklist:
// 1. What happened? (clear description)
// 2. Why? (context from wrapped error)
// 3. What can user do? (suggested action)
```

### Pattern 3: Help Text Conventions
**What:** Consistent help text structure across all commands
**When to use:** POLISH-02 - ensuring help text is comprehensive
**Example:**
```go
// Source: Cobra best practices + project patterns

func NewUpdateCmd() *cobra.Command {
    return &cobra.Command{
        Use:   "update [VERSION]",  // Include argument placeholders
        Short: "Download and install a new version",  // One line, imperative
        Long: `Download and install the newest available version, or a specific version if specified.

After installation, old versions are automatically removed according to InstancesMax
unless --no-vacuum is specified.

With --reboot flag, the system will reboot after a successful update to activate
the new extensions.`,  // Multiple paragraphs for detail
        Example: `  updex update                  # Install newest version
  updex update 1.2.0            # Install specific version
  updex update --component foo  # Update specific component
  updex update --reboot         # Update and reboot`,  // Real examples
        Args: cobra.MaximumNArgs(1),
        RunE: runUpdate,
    }
}
```

### Pattern 4: Shell Completion Testing
**What:** Scripts to verify shell completions work correctly
**When to use:** POLISH-03 - testing bash/zsh/fish completions
**Example:**
```bash
#!/bin/bash
# scripts/test-completions.sh

# Test bash completion generation
echo "Testing bash completion generation..."
updex completion bash > /tmp/updex_completion.bash || exit 1
echo "✓ Bash completion generated"

# Test that completion can be sourced
source /tmp/updex_completion.bash || exit 1
echo "✓ Bash completion can be sourced"

# Test that _updex function exists
type _updex >/dev/null 2>&1 || exit 1
echo "✓ _updex completion function exists"

# Test zsh completion
echo "Testing zsh completion generation..."
updex completion zsh > /tmp/_updex || exit 1
echo "✓ Zsh completion generated"

# Test fish completion
echo "Testing fish completion generation..."
updex completion fish > /tmp/updex.fish || exit 1
echo "✓ Fish completion generated"

echo "All completion tests passed!"
```

### Anti-Patterns to Avoid
- **Cryptic technical errors:** "ENOENT: /var/lib/extensions" → "Extensions directory not found: /var/lib/extensions"
- **Stack traces in user output:** Don't expose internal call stacks; log details, show summary to user
- **Missing examples:** Every command should have at least one example in help text
- **Inconsistent flag descriptions:** Review all flags for consistent phrasing
- **Hardcoded paths in tests:** Always use t.TempDir(), never assume /tmp or system paths

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Shell completions | Custom completion scripts | cobra's built-in `completion` command | Handles bash/zsh/fish/powershell correctly |
| Styled help output | Manual ANSI formatting | charmbracelet/fang | Already integrated, handles themes/colors |
| Styled errors | Custom error printing | fang's error rendering | Already active, formats errors nicely |
| Integration test HTTP | Real network calls | httptest.NewServer() | Already in use, reliable, fast |
| Error wrapping | Custom error types | fmt.Errorf with %w | Standard Go pattern, sufficient |

**Key insight:** The polish work is content-focused (message wording, help text, completion testing) not infrastructure-focused. Don't add new libraries or frameworks.

## Common Pitfalls

### Pitfall 1: Over-Engineering Error Messages
**What goes wrong:** Adding complex error hierarchies or custom error types
**Why it happens:** Desire to categorize errors programmatically
**How to avoid:** Keep it simple - fmt.Errorf with %w is sufficient; focus on message wording
**Warning signs:** Creating Error struct hierarchies, adding error code enums

### Pitfall 2: Testing Completions Programmatically
**What goes wrong:** Trying to write Go tests that verify shell completion behavior
**Why it happens:** Desire for automated testing
**How to avoid:** Test completion script generation, then manually verify in real shells; use helper script
**Warning signs:** Complex mocking of readline/bash internals

### Pitfall 3: Duplicating Test Setup
**What goes wrong:** Integration tests duplicate setup code from unit tests
**Why it happens:** Integration tests need more complex setup
**How to avoid:** Extract common setup into testutil package; reuse existing helpers
**Warning signs:** Copy-pasting large setup blocks between test files

### Pitfall 4: Testing Implementation Instead of Behavior
**What goes wrong:** Integration tests verify internal state rather than observable outcomes
**Why it happens:** Wanting comprehensive coverage
**How to avoid:** Test what users observe: files created, output messages, exit codes
**Warning signs:** Tests checking mock call counts, internal variable values

### Pitfall 5: Ignoring Error Context
**What goes wrong:** Error messages lose context as they propagate up the stack
**Why it happens:** Simple error wrapping without adding context
**How to avoid:** Add context at each level: "update failed: download failed: network error"
**Warning signs:** User sees only innermost error, loses what operation failed

### Pitfall 6: Help Text That Duplicates Flag Names
**What goes wrong:** Help text says "use --json for JSON output"
**Why it happens:** Writing help text mechanically
**How to avoid:** Help text should explain WHY and WHEN, not just repeat flag names
**Warning signs:** Help text that adds no information beyond flag --help

## Code Examples

Verified patterns from project and best practices:

### Integration Test Setup Helper
```go
// Source: Extended from existing project patterns

// IntegrationTestEnv holds a complete test environment
type IntegrationTestEnv struct {
    ConfigDir  string
    TargetDir  string
    Server     *httptest.Server
    Client     *Client
    MockRunner *sysext.MockRunner
    cleanup    func()
}

func NewIntegrationTestEnv(t *testing.T, files testutil.TestServerFiles) *IntegrationTestEnv {
    t.Helper()
    
    configDir := t.TempDir()
    targetDir := t.TempDir()
    
    mockRunner := &sysext.MockRunner{}
    runnerCleanup := sysext.SetRunner(mockRunner)
    
    server := testutil.NewTestServer(t, files)
    
    env := &IntegrationTestEnv{
        ConfigDir:  configDir,
        TargetDir:  targetDir,
        Server:     server,
        MockRunner: mockRunner,
        cleanup: func() {
            server.Close()
            runnerCleanup()
        },
    }
    
    // Create client
    env.Client = NewClient(ClientConfig{Definitions: configDir})
    
    t.Cleanup(env.cleanup)
    return env
}

// AddComponent sets up a component with transfer config
func (e *IntegrationTestEnv) AddComponent(t *testing.T, name string) {
    t.Helper()
    createTransferFile(t, e.ConfigDir, name, e.Server.URL)
    updateTransferTargetPath(t, e.ConfigDir, e.TargetDir)
}
```

### User-Focused Error Messages
```go
// Source: Error message improvement patterns

// BEFORE: Technical
return fmt.Errorf("failed to fetch index from %s: %w", indexURL, err)

// AFTER: User-focused
return fmt.Errorf("could not retrieve extension list from repository\n  URL: %s\n  Cause: %v\n\nTry: Check your network connection or verify the repository URL", 
    indexURL, err)

// Guidelines:
// - First line: What failed (user's perspective)
// - Details: Technical info indented
// - Suggestion: Actionable next step

// Common improvements:
// "no transfer configurations found" → "no extensions configured; run 'updex install <url> --component <name>' to add one"
// "component name is required" → "missing --component flag; specify which extension to operate on"
// "this operation requires root privileges" → "root privileges required; try running with sudo"
```

### Comprehensive Help Text Template
```go
// Source: Cobra documentation + CLI best practices

var installCmd = &cobra.Command{
    Use:   "install URL",
    Short: "Install an extension from a remote repository",
    Long: `Install an extension from a remote repository.

Downloads the extension metadata (.transfer file) and the extension itself,
placing them in the system configuration. After installation, reboot to 
activate the extension.

ARGUMENTS:
  URL    Repository URL (e.g., https://repo.example.com/extensions)

WORKFLOW:
  1. Fetches extension list from URL/ext/index
  2. Downloads .transfer configuration to /etc/sysupdate.d/
  3. Downloads the extension image to staging directory
  4. Extension becomes active after reboot

REQUIREMENTS:
  - Root privileges (run with sudo)
  - Network access to repository
  - Sufficient disk space`,
    Example: `  # Install VSCode extension from repository
  updex install https://repo.frostyard.org --component vscode
  
  # Install Docker extension
  updex install https://repo.example.com --component docker
  
  # Install without automatic sysext refresh
  updex install https://repo.example.com --component myext --no-refresh`,
    Args: cobra.ExactArgs(1),
    RunE: runInstall,
}
```

### Shell Completion Verification
```go
// Source: Testing shell completion script generation

func TestCompletionBashGeneration(t *testing.T) {
    // Create root command as it would be in main
    rootCmd := &cobra.Command{Use: "updex"}
    
    // Add completion command (cobra does this by default with fang)
    
    // Capture completion output
    var buf bytes.Buffer
    rootCmd.SetOut(&buf)
    rootCmd.SetArgs([]string{"completion", "bash"})
    
    if err := rootCmd.Execute(); err != nil {
        t.Fatalf("completion command failed: %v", err)
    }
    
    output := buf.String()
    
    // Verify critical parts of completion script
    if !strings.Contains(output, "bash completion V2 for updex") {
        t.Error("missing bash completion header")
    }
    if !strings.Contains(output, "_updex") {
        t.Error("missing _updex function")
    }
    if !strings.Contains(output, "update") {
        t.Error("missing 'update' command in completions")
    }
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual shell completion scripts | Cobra built-in generation | Cobra 1.x | Automatic bash/zsh/fish/powershell support |
| Custom help formatting | fang styled output | Project adopted fang | Consistent styled CLI |
| Unit tests only | Unit + integration tests | Best practice | Catches workflow bugs |
| fmt.Println errors | fang error styling | Project adopted fang | Styled error output |

**Deprecated/outdated:**
- Manual ANSI codes for colors: Use fang's styling
- Shell completion bash v1: Cobra defaults to v2 completion

## Open Questions

Things that couldn't be fully resolved:

1. **Dynamic completions for --component flag?**
   - What we know: Cobra supports ValidArgsFunction for dynamic completions
   - What's unclear: Should --component complete with installed components?
   - Recommendation: Start with static completions; add dynamic if users request it

2. **How comprehensive should Example sections be?**
   - What we know: Some commands have examples, some don't
   - What's unclear: One example per use case, or minimal?
   - Recommendation: At least 2-3 examples per command covering common use cases

3. **Should error messages include documentation URLs?**
   - What we know: Some CLI tools link to docs in errors
   - What's unclear: Does updex have enough docs to link to?
   - Recommendation: Start without URLs; add when documentation is comprehensive

## Sources

### Primary (HIGH confidence)
- Existing project test patterns (updex/*_test.go, internal/*_test.go)
- Existing project error handling (grep of fmt.Errorf patterns)
- charmbracelet/fang GitHub README - CLI enhancement features
- spf13/cobra documentation - shell completion features
- Existing help text in cmd/commands/*.go

### Secondary (MEDIUM confidence)
- Go testing best practices (go.dev documentation)
- CLI UX guidelines from 12 Factor CLI Apps

### Tertiary (LOW confidence)
- None

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Using existing project infrastructure, no new libraries
- Architecture: HIGH - Extending existing test patterns, auditing existing code
- Pitfalls: HIGH - Based on project experience and common Go CLI patterns
- Code examples: HIGH - Adapted from verified existing project patterns

**Research date:** 2026-01-26
**Valid until:** 2026-02-26 (stable domain, no fast-moving dependencies)
