---
phase: 05-integration-polish
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/test-completions.sh
  - cmd/commands/completion_test.go
autonomous: true

must_haves:
  truths:
    - "Bash completion scripts can be generated"
    - "Zsh completion scripts can be generated"
    - "Fish completion scripts can be generated"
    - "Completion scripts can be sourced without error"
  artifacts:
    - path: "scripts/test-completions.sh"
      provides: "Shell completion verification script"
      min_lines: 20
    - path: "cmd/commands/completion_test.go"
      provides: "Completion generation unit tests"
      contains: "TestCompletion"
  key_links:
    - from: "scripts/test-completions.sh"
      to: "updex completion bash"
      via: "CLI invocation"
      pattern: "updex completion"
---

<objective>
Verify shell completions work correctly for bash, zsh, and fish shells.

Purpose: Fulfills POLISH-03. Users with shell completions enabled can tab-complete updex commands and flags.
Output: Verification script and unit tests confirming completion generation works.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-integration-polish/05-RESEARCH.md

# Root command with completion support
@cmd/updex/root.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shell completion test script</name>
  <files>scripts/test-completions.sh</files>
  <action>
Create `scripts/test-completions.sh` that verifies shell completions work:

```bash
#!/bin/bash
# Test shell completion script generation for updex
# Usage: ./scripts/test-completions.sh [path-to-updex-binary]

set -e

UPDEX="${1:-./updex}"

if [ ! -x "$UPDEX" ]; then
    echo "Error: updex binary not found at $UPDEX"
    echo "Build first: go build -o updex ./cmd/updex/"
    exit 1
fi

echo "Testing shell completions with: $UPDEX"
echo

# Test bash completion
echo "=== Bash Completion ==="
echo -n "Generating... "
$UPDEX completion bash > /tmp/updex_completion.bash
echo "OK"

echo -n "Validating syntax... "
bash -n /tmp/updex_completion.bash
echo "OK"

echo -n "Checking for _updex function... "
grep -q "_updex" /tmp/updex_completion.bash
echo "OK"

echo -n "Checking for subcommands... "
grep -q "update\|install\|remove\|list" /tmp/updex_completion.bash
echo "OK"

echo

# Test zsh completion
echo "=== Zsh Completion ==="
echo -n "Generating... "
$UPDEX completion zsh > /tmp/_updex
echo "OK"

echo -n "Checking for compdef... "
grep -q "compdef" /tmp/_updex
echo "OK"

echo

# Test fish completion
echo "=== Fish Completion ==="
echo -n "Generating... "
$UPDEX completion fish > /tmp/updex.fish
echo "OK"

echo -n "Checking for complete command... "
grep -q "complete" /tmp/updex.fish
echo "OK"

echo
echo "All completion tests passed!"
```

Make the script executable with chmod +x.
  </action>
  <verify>`./scripts/test-completions.sh ./updex` exits with code 0</verify>
  <done>Shell completion test script exists and is executable</done>
</task>

<task type="auto">
  <name>Task 2: Create completion generation unit tests</name>
  <files>cmd/commands/completion_test.go</files>
  <action>
Create `cmd/commands/completion_test.go` with unit tests for completion generation:

```go
package commands

import (
    "bytes"
    "strings"
    "testing"

    "github.com/spf13/cobra"
)

// TestCompletionBash verifies bash completion script generation
func TestCompletionBash(t *testing.T) {
    rootCmd := createTestRootCmd()
    
    var buf bytes.Buffer
    rootCmd.SetOut(&buf)
    rootCmd.SetArgs([]string{"completion", "bash"})
    
    if err := rootCmd.Execute(); err != nil {
        t.Fatalf("completion bash failed: %v", err)
    }
    
    output := buf.String()
    
    tests := []struct {
        name    string
        contains string
    }{
        {"bash header", "bash completion V2"},
        {"main function", "_updex"},
        {"update command", "update"},
        {"install command", "install"},
        {"remove command", "remove"},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if !strings.Contains(output, tt.contains) {
                t.Errorf("bash completion missing %q", tt.contains)
            }
        })
    }
}

// TestCompletionZsh verifies zsh completion script generation
func TestCompletionZsh(t *testing.T) {
    rootCmd := createTestRootCmd()
    
    var buf bytes.Buffer
    rootCmd.SetOut(&buf)
    rootCmd.SetArgs([]string{"completion", "zsh"})
    
    if err := rootCmd.Execute(); err != nil {
        t.Fatalf("completion zsh failed: %v", err)
    }
    
    output := buf.String()
    
    if !strings.Contains(output, "compdef") {
        t.Error("zsh completion missing compdef")
    }
    if !strings.Contains(output, "_updex") {
        t.Error("zsh completion missing _updex function")
    }
}

// TestCompletionFish verifies fish completion script generation
func TestCompletionFish(t *testing.T) {
    rootCmd := createTestRootCmd()
    
    var buf bytes.Buffer
    rootCmd.SetOut(&buf)
    rootCmd.SetArgs([]string{"completion", "fish"})
    
    if err := rootCmd.Execute(); err != nil {
        t.Fatalf("completion fish failed: %v", err)
    }
    
    output := buf.String()
    
    if !strings.Contains(output, "complete") {
        t.Error("fish completion missing complete command")
    }
}

// createTestRootCmd creates a root command with subcommands for testing
func createTestRootCmd() *cobra.Command {
    rootCmd := &cobra.Command{
        Use:   "updex",
        Short: "Test root command",
    }
    
    // Add commands that should appear in completions
    rootCmd.AddCommand(NewListCmd())
    rootCmd.AddCommand(NewCheckCmd())
    rootCmd.AddCommand(NewUpdateCmd())
    rootCmd.AddCommand(NewInstallCmd())
    rootCmd.AddCommand(NewRemoveCmd())
    rootCmd.AddCommand(NewDaemonCmd())
    
    return rootCmd
}
```

This tests that cobra's built-in completion command generates valid scripts with expected content.
  </action>
  <verify>`go test -v ./cmd/commands/ -run TestCompletion` passes</verify>
  <done>Unit tests verify bash, zsh, and fish completion generation</done>
</task>

<task type="auto">
  <name>Task 3: Run and verify all completion tests</name>
  <files>scripts/test-completions.sh</files>
  <action>
Build the binary and run all completion tests:

1. Build: `go build -o updex ./cmd/updex/`
2. Run unit tests: `go test -v ./cmd/commands/ -run TestCompletion`
3. Run script test: `./scripts/test-completions.sh ./updex`
4. Verify bash completion can be sourced:
   ```bash
   source /tmp/updex_completion.bash
   # Should not error
   ```

If tests fail because completion command doesn't exist, note that fang/cobra may register it automatically. Check if `updex completion --help` works.

If completion command is missing, it needs to be added to root.go. But typically cobra provides it by default when using fang.

Clean up: `rm ./updex` after testing.
  </action>
  <verify>`make test` passes including completion tests</verify>
  <done>All shell completion tests pass (unit tests + script verification)</done>
</task>

</tasks>

<verification>
- `go test -v ./cmd/commands/ -run TestCompletion` shows 3 passing tests
- `./scripts/test-completions.sh ./updex` exits successfully
- `updex completion bash | head -5` shows valid bash script header
- `updex completion zsh | head -5` shows valid zsh script header
- `updex completion fish | head -5` shows valid fish script header
</verification>

<success_criteria>
- POLISH-03 fulfilled: Shell completions work for bash, zsh, and fish
- Unit tests verify completion script generation
- Verification script provides manual testing capability
- Completions include all subcommands (update, install, remove, list, etc.)
</success_criteria>

<output>
After completion, create `.planning/phases/05-integration-polish/05-03-SUMMARY.md`
</output>
