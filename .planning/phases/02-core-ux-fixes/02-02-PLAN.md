---
phase: 02-core-ux-fixes
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - updex/features_test.go
autonomous: true

must_haves:
  truths:
    - "Tests verify EnableFeature --now downloads extensions"
    - "Tests verify DisableFeature --now removes files"
    - "Tests verify merge state blocking without --force"
    - "Tests verify --dry-run doesn't modify filesystem"
  artifacts:
    - path: "updex/features_test.go"
      provides: "Unit tests for enable/disable with --now, --force, --dry-run"
      min_lines: 150
  key_links:
    - from: "updex/features_test.go"
      to: "updex.EnableFeature"
      via: "test cases calling EnableFeature with options"
      pattern: "EnableFeature.*EnableFeatureOptions"
    - from: "updex/features_test.go"
      to: "updex.DisableFeature"
      via: "test cases calling DisableFeature with options"
      pattern: "DisableFeature.*DisableFeatureOptions"
---

<objective>
Add comprehensive unit tests for EnableFeature and DisableFeature with --now, --force, and --dry-run flags.

Purpose: Verify that the new enable/disable semantics work correctly and safely, especially merge state checking and file removal.
Output: features_test.go with tests covering all new flag combinations.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-ux-fixes/02-01-SUMMARY.md

# Test patterns from Phase 1
@.planning/phases/01-test-foundation/01-01-SUMMARY.md
@.planning/phases/01-test-foundation/01-02-SUMMARY.md

# Source files
@updex/features.go
@updex/options.go
@updex/list_test.go
@updex/update_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create features_test.go with enable/disable tests</name>
  <files>
    updex/features_test.go
  </files>
  <action>
Create `updex/features_test.go` following the testing patterns established in Phase 1:

1. Use the same test helpers from Phase 1:
   - `createTransferFile` for creating test transfer configs
   - `updateTransferTargetPath` for setting paths
   - Mock HTTP server for manifest/downloads
   - Mock SysextRunner from `internal/sysext`

2. Create test fixtures:
   - Feature file in temp directory with `[Feature]\nEnabled=true`
   - Transfer file associated with the feature
   - Mock manifest with test extension files
   - Test extension files in target directory (for disable tests)

3. Write test functions:

```go
func TestEnableFeature_Now_DownloadsExtensions(t *testing.T) {
    // Setup:
    // - Create feature file (disabled)
    // - Create transfer file for feature
    // - Mock HTTP server with manifest + extension file
    // - Mock SysextRunner
    
    // Act:
    client := updex.NewClient(cfg)
    result, err := client.EnableFeature(ctx, "testfeature", updex.EnableFeatureOptions{
        Now: true,
    })
    
    // Assert:
    // - result.Success == true
    // - result.DownloadedFiles contains expected file
    // - Drop-in file was created
    // - Extension file exists in target dir
}

func TestEnableFeature_DryRun_NoChanges(t *testing.T) {
    // Setup: same as above
    
    // Act: EnableFeature with DryRun: true
    
    // Assert:
    // - result.DryRun == true
    // - No drop-in file created
    // - No files downloaded
    // - result.DownloadedFiles lists what WOULD be downloaded
}

func TestEnableFeature_WithoutNow_OnlyConfig(t *testing.T) {
    // Setup: same as above
    
    // Act: EnableFeature with Now: false (default)
    
    // Assert:
    // - Drop-in file created
    // - No files downloaded
    // - NextActionMessage suggests running 'updex update'
}

func TestDisableFeature_Now_RemovesFiles(t *testing.T) {
    // Setup:
    // - Create enabled feature
    // - Create transfer file
    // - Create test extension files in target dir
    // - Mock SysextRunner (Unmerge returns success)
    
    // Act:
    result, err := client.DisableFeature(ctx, "testfeature", updex.DisableFeatureOptions{
        Now: true,
    })
    
    // Assert:
    // - result.Success == true
    // - result.RemovedFiles contains expected files
    // - result.Unmerged == true
    // - Extension files no longer exist
}

func TestDisableFeature_MergedExtension_RequiresForce(t *testing.T) {
    // Setup:
    // - Create enabled feature
    // - Create transfer with CurrentSymlink
    // - Create symlink in target dir (simulates installed)
    // - Create /run/extensions/component_1.0.0.raw (simulates merged)
    //   OR mock GetActiveVersion to return a version
    
    // Act:
    result, err := client.DisableFeature(ctx, "testfeature", updex.DisableFeatureOptions{
        Now:   true,
        Force: false,
    })
    
    // Assert:
    // - err != nil
    // - result.Error contains "is active" and "--force"
    // - No files were removed
}

func TestDisableFeature_MergedExtension_WithForce_Removes(t *testing.T) {
    // Setup: same as above
    
    // Act:
    result, err := client.DisableFeature(ctx, "testfeature", updex.DisableFeatureOptions{
        Now:   true,
        Force: true,
    })
    
    // Assert:
    // - result.Success == true
    // - Files were removed
    // - NextActionMessage mentions reboot
}

func TestDisableFeature_DryRun_NoChanges(t *testing.T) {
    // Setup:
    // - Create enabled feature
    // - Create extension files
    
    // Act:
    result, err := client.DisableFeature(ctx, "testfeature", updex.DisableFeatureOptions{
        Now:    true,
        DryRun: true,
    })
    
    // Assert:
    // - result.DryRun == true
    // - Extension files still exist
    // - result.RemovedFiles lists what WOULD be removed
}
```

4. Use table-driven tests where appropriate (e.g., different flag combinations)

5. Follow Phase 1 patterns:
   - Use `t.TempDir()` for test directories
   - Use `sysext.SetRunner()` with cleanup for mock injection
   - Use `httptest.NewServer()` for mock HTTP
   - Hash test content correctly with SHA256
  </action>
  <verify>
```bash
# Tests compile
go build ./updex/...

# Tests pass
go test ./updex/... -v -run TestEnableFeature
go test ./updex/... -v -run TestDisableFeature

# All tests pass
go test ./...

# Coverage increased
go test ./updex/... -coverprofile=coverage.out
go tool cover -func=coverage.out | grep features
```
  </verify>
  <done>
- features_test.go exists with comprehensive tests
- TestEnableFeature_Now_DownloadsExtensions passes
- TestEnableFeature_DryRun_NoChanges passes
- TestEnableFeature_WithoutNow_OnlyConfig passes
- TestDisableFeature_Now_RemovesFiles passes
- TestDisableFeature_MergedExtension_RequiresForce passes
- TestDisableFeature_MergedExtension_WithForce_Removes passes
- TestDisableFeature_DryRun_NoChanges passes
- Coverage for features.go increased
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify CI passes and update coverage metrics</name>
  <files>
    .planning/STATE.md
  </files>
  <action>
1. Run full CI validation locally:
   ```bash
   # Lint
   golangci-lint run
   
   # Security scan
   govulncheck ./...
   
   # Verify (same as CI)
   go mod tidy
   git diff --exit-code go.mod go.sum
   go vet ./...
   gofmt -l .
   
   # Unit tests
   go test ./... -race -coverprofile=coverage.out
   
   # Check coverage
   go tool cover -func=coverage.out
   
   # Build
   GOOS=linux GOARCH=amd64 go build -o /dev/null ./cmd/...
   GOOS=linux GOARCH=arm64 go build -o /dev/null ./cmd/...
   ```

2. If any failures, fix them:
   - Lint issues: fix code style
   - Test failures: debug and fix
   - Build failures: resolve compilation errors

3. Update `.planning/STATE.md` with new coverage metrics:
   - Read current STATE.md
   - Update "Test Coverage" section with new numbers
   - Note the new test count

4. Commit all changes if tests pass
  </action>
  <verify>
```bash
# All CI-equivalent checks pass
go test ./... -race
golangci-lint run
go build ./...
```
  </verify>
  <done>
- All tests pass including new features_test.go tests
- Lint passes with no new warnings
- STATE.md updated with new coverage metrics
- Ready for Phase 2 verification
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

```bash
# All tests pass
go test ./... -v

# Specific feature tests pass
go test ./updex/... -v -run "Feature"

# Coverage report shows features.go tested
go test ./updex/... -coverprofile=coverage.out
go tool cover -func=coverage.out | grep features

# CI checks pass
golangci-lint run
go vet ./...
go build ./...
```
</verification>

<success_criteria>
1. features_test.go exists with 7+ test functions
2. All new tests pass
3. All existing tests still pass
4. Coverage for features.go is > 50%
5. CI checks pass (lint, vet, test, build)
6. STATE.md updated with new metrics
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-ux-fixes/02-02-SUMMARY.md`
</output>
