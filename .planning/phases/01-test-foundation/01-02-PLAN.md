---
phase: 01-test-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - updex/list_test.go
  - updex/check_test.go
  - updex/update_test.go
  - updex/install_test.go
  - updex/remove_test.go
  - internal/sysext/mock_runner.go
autonomous: true

must_haves:
  truths:
    - "go test ./updex/... passes without root"
    - "List operation has test coverage for happy path and errors"
    - "Check operation has test coverage for updates available and up-to-date"
    - "Update operation has test coverage including download simulation"
    - "Install operation has test coverage for happy path"
    - "Remove operation has test coverage"
  artifacts:
    - path: "updex/list_test.go"
      provides: "Tests for Client.List"
      contains: "func TestList"
    - path: "updex/check_test.go"
      provides: "Tests for Client.CheckNew"
      contains: "func TestCheckNew"
    - path: "updex/update_test.go"
      provides: "Tests for Client.Update"
      contains: "func TestUpdate"
    - path: "updex/remove_test.go"
      provides: "Tests for Client.Remove"
      contains: "func TestRemove"
    - path: "internal/sysext/mock_runner.go"
      provides: "MockRunner for tests"
      exports: ["MockRunner"]
  key_links:
    - from: "updex/list_test.go"
      to: "internal/testutil/httpserver.go"
      via: "uses test server"
      pattern: "testutil\\.NewTestServer"
    - from: "updex/update_test.go"
      to: "internal/sysext/mock_runner.go"
      via: "uses mock runner"
      pattern: "MockRunner"
---

<objective>
Add unit tests for core updex operations (list, check, update, install, remove).

Purpose: Achieve test coverage for the main Client operations, proving they work correctly without requiring root privileges by using the test infrastructure from Plan 01.

Output: Test files for all core operations with table-driven tests covering happy paths and error cases.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-test-foundation/01-CONTEXT.md
@.planning/phases/01-test-foundation/01-RESEARCH.md
@.planning/phases/01-test-foundation/01-01-SUMMARY.md
@updex/list.go
@updex/check.go
@updex/update.go
@updex/install.go
@updex/remove.go
@internal/sysext/runner.go
@internal/testutil/httpserver.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MockRunner and test List/Check operations</name>
  <files>internal/sysext/mock_runner.go, updex/list_test.go, updex/check_test.go</files>
  <action>
**1. Create `internal/sysext/mock_runner.go`:**

```go
package sysext

// MockRunner is a test double for SysextRunner
type MockRunner struct {
    RefreshCalled bool
    RefreshErr    error
    MergeCalled   bool
    MergeErr      error
    UnmergeCalled bool
    UnmergeErr    error
}

func (m *MockRunner) Refresh() error {
    m.RefreshCalled = true
    return m.RefreshErr
}

func (m *MockRunner) Merge() error {
    m.MergeCalled = true
    return m.MergeErr
}

func (m *MockRunner) Unmerge() error {
    m.UnmergeCalled = true
    return m.UnmergeErr
}
```

**2. Create `updex/list_test.go`:**

Use table-driven tests with:
- Test setup: temp dirs for config and target, httptest.Server for manifest
- Create transfer files using inline content (like config/transfer_test.go)
- Create installed version files in target dir

Test cases:
- "list versions with remote and installed" - has available + installed versions
- "list with no transfer configs" - returns error
- "list filters by component" - opts.Component filtering works
- "list with HTTP error" - graceful handling when manifest fetch fails

Pattern:
```go
func TestList(t *testing.T) {
    tests := []struct {
        name        string
        setupServer func(*testing.T) *httptest.Server
        setupConfig func(*testing.T, string, string) // (configDir, serverURL)
        setupTarget func(*testing.T, string)         // targetDir
        opts        ListOptions
        wantLen     int
        wantErr     bool
    }{...}
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            configDir := t.TempDir()
            targetDir := t.TempDir()
            
            server := tt.setupServer(t)
            defer server.Close()
            
            tt.setupConfig(t, configDir, server.URL)
            tt.setupTarget(t, targetDir)
            
            // Inject mock runner to avoid real sysext calls
            mockRunner := &sysext.MockRunner{}
            defer sysext.SetRunner(mockRunner)()
            
            client := NewClient(ClientConfig{Definitions: configDir})
            results, err := client.List(context.Background(), tt.opts)
            
            // assertions...
        })
    }
}
```

**3. Create `updex/check_test.go`:**

Test cases:
- "update available" - remote has newer version than installed
- "up to date" - installed version matches newest remote
- "no installed versions" - update available when nothing installed
- "remote fetch fails" - component skipped with warning

Similar pattern to list_test.go.
  </action>
  <verify>
- `go build ./internal/sysext/...` compiles
- `go test ./updex/... -run TestList` passes
- `go test ./updex/... -run TestCheckNew` passes
- Tests run without root (no permission errors)
  </verify>
  <done>
- MockRunner exists for test injection
- List has at least 3 test cases covering normal flow and errors
- Check has at least 3 test cases covering update scenarios
- All tests pass without root
  </done>
</task>

<task type="auto">
  <name>Task 2: Test Update and Remove operations</name>
  <files>updex/update_test.go, updex/remove_test.go</files>
  <action>
**1. Create `updex/update_test.go`:**

Update is more complex - it downloads files. Use testutil.NewTestServer with Content map for downloadable files.

Test cases:
- "updates to newest version" - downloads file, creates symlink
- "already installed and current" - skips download
- "specific version requested" - installs exact version
- "version not found" - returns error
- "download fails" - returns error (use error server)

Key setup:
- Create transfer file pointing to test server
- Server returns SHA256SUMS manifest AND file content
- Need to compute real SHA256 hash of test content for manifest
- Use target dir from t.TempDir()

Pattern for hash computation:
```go
content := []byte("fake extension content")
h := sha256.Sum256(content)
hash := fmt.Sprintf("%x", h[:])
```

Mock runner should be injected to avoid real Refresh() calls.

**2. Create `updex/remove_test.go`:**

Test cases:
- "removes installed files" - files deleted from target dir
- "component not found" - returns error
- "no files to remove" - graceful handling
- "with --now flag" - calls Unmerge (verify on mock)

Remove doesn't need HTTP server - it works on local files only.

Pattern:
- Create transfer file
- Create installed files in target dir
- Call Remove
- Verify files are deleted
- Verify MockRunner.UnmergeCalled for Now option
  </action>
  <verify>
- `go test ./updex/... -run TestUpdate` passes
- `go test ./updex/... -run TestRemove` passes
- Tests run without root
- Update tests verify mock runner was called for Refresh
  </verify>
  <done>
- Update has at least 4 test cases covering download, skip, error scenarios
- Remove has at least 3 test cases covering deletion and --now flag
- Tests verify MockRunner method calls where appropriate
- All tests pass without root
  </done>
</task>

<task type="auto">
  <name>Task 3: Test Install operation and run full test suite</name>
  <files>updex/install_test.go</files>
  <action>
**1. Create `updex/install_test.go`:**

Install is complex - it fetches index, downloads transfer file, then calls installTransfer.

Test cases:
- "installs from repository" - full flow with mocked HTTP
- "component not in index" - returns error
- "transfer file download fails" - returns error

Key setup:
- Server serves /ext/index (list of extension names, one per line)
- Server serves /ext/{component}/{component}.transfer (transfer file content)
- Server serves manifest and files at source path

Simplify by testing at component level:
- Create server that serves all needed endpoints
- Use temp dir for config (where transfer file will be written)
- Install should write transfer file and download extension

Note: Install writes to /etc/sysupdate.d by default which needs root. For testing, you may need to either:
1. Skip the transfer file write test (test that validation works)
2. Mock the file write (more complex)
3. Test the installTransfer helper directly (has transfer already)

Recommendation: Focus on testing installTransfer (the core logic) with a pre-created transfer config. Test that Install validates input correctly. Skip the full Install flow that writes to /etc.

Alternative approach - test Install logic by mocking downloadTransferFile or test components separately.

**2. Run full test suite:**

After creating all tests:
```bash
go test ./... -v
```

Ensure all tests pass without root.
  </action>
  <verify>
- `go test ./updex/... -run TestInstall` passes
- `go test ./...` passes (full suite)
- All tests run without root privileges
- No tests require network access (all use httptest)
  </verify>
  <done>
- Install has at least 2 test cases (validation, installTransfer)
- Full test suite passes: `go test ./...`
- All core operations have test coverage
- Tests run without root
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `go test ./... -v` - all tests pass
2. Run `go test ./... -count=1` without sudo - no permission errors
3. Verify test coverage for updex package:
   ```bash
   go test ./updex/... -cover
   ```
4. Verify no tests skip or require special setup
</verification>

<success_criteria>
1. MockRunner exists and is used by tests
2. List operation: 3+ test cases, tests pass
3. Check operation: 3+ test cases, tests pass
4. Update operation: 4+ test cases, tests pass
5. Remove operation: 3+ test cases, tests pass
6. Install operation: 2+ test cases, tests pass
7. All tests run without root privileges
8. Full test suite passes: `go test ./...`
</success_criteria>

<output>
After completion, create `.planning/phases/01-test-foundation/01-02-SUMMARY.md`
</output>
