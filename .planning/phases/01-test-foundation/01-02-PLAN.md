---
phase: 01-test-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - updex/list_test.go
  - updex/check_test.go
  - updex/update_test.go
  - updex/install_test.go
  - updex/remove_test.go
  - internal/sysext/mock_runner.go
autonomous: true

must_haves:
  truths:
    - "go test ./updex/... passes without root"
    - "List operation has test coverage for happy path and errors"
    - "Check operation has test coverage for updates available and up-to-date"
    - "Update operation has test coverage including download simulation"
    - "Install operation has test coverage for happy path"
    - "Remove operation has test coverage"
  notes:
    - requirement: "TEST-02"
      status: "already-satisfied"
      reason: "Config parsing tests already exist in internal/config/transfer_test.go (370 lines) and internal/config/feature_test.go (452 lines) with comprehensive coverage of parsing, defaults, validation, and edge cases"
  artifacts:
    - path: "updex/list_test.go"
      provides: "Tests for Client.List"
      contains: "func TestList"
    - path: "updex/check_test.go"
      provides: "Tests for Client.CheckNew"
      contains: "func TestCheckNew"
    - path: "updex/update_test.go"
      provides: "Tests for Client.Update"
      contains: "func TestUpdate"
    - path: "updex/remove_test.go"
      provides: "Tests for Client.Remove"
      contains: "func TestRemove"
    - path: "internal/sysext/mock_runner.go"
      provides: "MockRunner for tests"
      exports: ["MockRunner"]
  key_links:
    - from: "updex/list_test.go"
      to: "internal/testutil/httpserver.go"
      via: "uses test server"
      pattern: "testutil\\.NewTestServer"
    - from: "updex/update_test.go"
      to: "internal/sysext/mock_runner.go"
      via: "uses mock runner"
      pattern: "MockRunner"
---

<objective>
Add unit tests for core updex operations (list, check, update, install, remove).

Purpose: Achieve test coverage for the main Client operations, proving they work correctly without requiring root privileges by using the test infrastructure from Plan 01.

Output: Test files for all core operations with table-driven tests covering happy paths and error cases.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-test-foundation/01-CONTEXT.md
@.planning/phases/01-test-foundation/01-RESEARCH.md
@.planning/phases/01-test-foundation/01-01-SUMMARY.md
@updex/list.go
@updex/check.go
@updex/update.go
@updex/install.go
@updex/remove.go
@internal/sysext/runner.go
@internal/testutil/httpserver.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MockRunner and test List/Check operations</name>
  <files>internal/sysext/mock_runner.go, updex/list_test.go, updex/check_test.go</files>
  <action>
**1. Create `internal/sysext/mock_runner.go`:**

```go
package sysext

// MockRunner is a test double for SysextRunner
type MockRunner struct {
    RefreshCalled bool
    RefreshErr    error
    MergeCalled   bool
    MergeErr      error
    UnmergeCalled bool
    UnmergeErr    error
}

func (m *MockRunner) Refresh() error {
    m.RefreshCalled = true
    return m.RefreshErr
}

func (m *MockRunner) Merge() error {
    m.MergeCalled = true
    return m.MergeErr
}

func (m *MockRunner) Unmerge() error {
    m.UnmergeCalled = true
    return m.UnmergeErr
}
```

**2. Create `updex/list_test.go`:**

Use table-driven tests with:
- Test setup: temp dirs for config and target, httptest.Server for manifest
- Create transfer files using inline content (like config/transfer_test.go)
- Create installed version files in target dir

Test cases:
- "list versions with remote and installed" - has available + installed versions
- "list with no transfer configs" - returns error
- "list filters by component" - opts.Component filtering works
- "list with HTTP error" - graceful handling when manifest fetch fails

Pattern:
```go
func TestList(t *testing.T) {
    tests := []struct {
        name        string
        setupServer func(*testing.T) *httptest.Server
        setupConfig func(*testing.T, string, string) // (configDir, serverURL)
        setupTarget func(*testing.T, string)         // targetDir
        opts        ListOptions
        wantLen     int
        wantErr     bool
    }{...}
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            configDir := t.TempDir()
            targetDir := t.TempDir()
            
            server := tt.setupServer(t)
            defer server.Close()
            
            tt.setupConfig(t, configDir, server.URL)
            tt.setupTarget(t, targetDir)
            
            // Inject mock runner to avoid real sysext calls
            mockRunner := &sysext.MockRunner{}
            defer sysext.SetRunner(mockRunner)()
            
            client := NewClient(ClientConfig{Definitions: configDir})
            results, err := client.List(context.Background(), tt.opts)
            
            // assertions...
        })
    }
}
```

**3. Create `updex/check_test.go`:**

Test cases:
- "update available" - remote has newer version than installed
- "up to date" - installed version matches newest remote
- "no installed versions" - update available when nothing installed
- "remote fetch fails" - component skipped with warning

Similar pattern to list_test.go.
  </action>
  <verify>
- `go build ./internal/sysext/...` compiles
- `go test ./updex/... -run TestList` passes
- `go test ./updex/... -run TestCheckNew` passes
- Tests run without root (no permission errors)
  </verify>
  <done>
- MockRunner exists for test injection
- List has at least 3 test cases covering normal flow and errors
- Check has at least 3 test cases covering update scenarios
- All tests pass without root
  </done>
</task>

<task type="auto">
  <name>Task 2: Test Update and Remove operations</name>
  <files>updex/update_test.go, updex/remove_test.go</files>
  <action>
**1. Create `updex/update_test.go`:**

Use same table-driven pattern as Task 1. Update is more complex - it downloads files. Use testutil.NewTestServer with Content map for downloadable files.

Test cases:
- "updates to newest version" - downloads file, creates symlink
- "already installed and current" - skips download
- "specific version requested" - installs exact version
- "version not found" - returns error
- "download fails" - returns error (use error server)

Pattern (following Task 1 structure):
```go
func TestUpdate(t *testing.T) {
    tests := []struct {
        name        string
        setupServer func(*testing.T) (*httptest.Server, []byte) // returns server and expected content
        setupConfig func(*testing.T, string, string)           // (configDir, serverURL)
        setupTarget func(*testing.T, string)                   // targetDir - pre-existing files
        opts        UpdateOptions
        wantErr     bool
        checkResult func(*testing.T, string, *sysext.MockRunner) // verify target dir + mock calls
    }{...}
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            configDir := t.TempDir()
            targetDir := t.TempDir()
            
            server, expectedContent := tt.setupServer(t)
            defer server.Close()
            
            tt.setupConfig(t, configDir, server.URL)
            tt.setupTarget(t, targetDir)
            
            mockRunner := &sysext.MockRunner{}
            defer sysext.SetRunner(mockRunner)()
            
            client := NewClient(ClientConfig{Definitions: configDir})
            err := client.Update(context.Background(), tt.opts)
            
            if (err != nil) != tt.wantErr {
                t.Errorf("Update() error = %v, wantErr %v", err, tt.wantErr)
            }
            if tt.checkResult != nil {
                tt.checkResult(t, targetDir, mockRunner)
            }
        })
    }
}
```

Key setup for hash computation (required for manifest validation):
```go
content := []byte("fake extension content")
h := sha256.Sum256(content)
hash := fmt.Sprintf("%x", h[:])

// Server setup with testutil.NewTestServer:
server := testutil.NewTestServer(t, testutil.TestServerFiles{
    Files:   map[string]string{"ext_1.0.0.raw": hash},
    Content: map[string][]byte{"ext_1.0.0.raw": content},
})
```

Transfer file template (create in setupConfig):
```go
transferContent := fmt.Sprintf(`[Source]
Type=url-file
Path=%s
MatchPattern=ext_@v.raw

[Target]
Path=%s
MatchPattern=ext_@v.raw
`, serverURL, targetDir)
os.WriteFile(filepath.Join(configDir, "ext.transfer"), []byte(transferContent), 0644)
```

**2. Create `updex/remove_test.go`:**

Test cases:
- "removes installed files" - files deleted from target dir
- "component not found" - returns error
- "no files to remove" - graceful handling
- "with --now flag" - calls Unmerge (verify on mock)

Remove doesn't need HTTP server - it works on local files only.

Pattern (following Task 1 structure):
```go
func TestRemove(t *testing.T) {
    tests := []struct {
        name        string
        setupConfig func(*testing.T, string, string) // (configDir, targetDir)
        setupTarget func(*testing.T, string)         // create installed files
        component   string
        opts        RemoveOptions
        wantErr     bool
        checkResult func(*testing.T, string, *sysext.MockRunner)
    }{...}
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            configDir := t.TempDir()
            targetDir := t.TempDir()
            
            tt.setupConfig(t, configDir, targetDir)
            tt.setupTarget(t, targetDir)
            
            mockRunner := &sysext.MockRunner{}
            defer sysext.SetRunner(mockRunner)()
            
            client := NewClient(ClientConfig{Definitions: configDir})
            err := client.Remove(context.Background(), tt.component, tt.opts)
            
            if (err != nil) != tt.wantErr {
                t.Errorf("Remove() error = %v, wantErr %v", err, tt.wantErr)
            }
            if tt.checkResult != nil {
                tt.checkResult(t, targetDir, mockRunner)
            }
        })
    }
}
```

Verification helper for file deletion:
```go
checkResult: func(t *testing.T, targetDir string, mock *sysext.MockRunner) {
    files, _ := filepath.Glob(filepath.Join(targetDir, "ext_*.raw"))
    if len(files) != 0 {
        t.Errorf("expected files to be removed, found %v", files)
    }
}
```

For --now flag, verify mock.UnmergeCalled:
```go
checkResult: func(t *testing.T, targetDir string, mock *sysext.MockRunner) {
    if !mock.UnmergeCalled {
        t.Error("expected Unmerge to be called with Now option")
    }
}
```
  </action>
  <verify>
- `go test ./updex/... -run TestUpdate` passes
- `go test ./updex/... -run TestRemove` passes
- Tests run without root
- Update tests verify mock runner was called for Refresh
  </verify>
  <done>
- Update has at least 4 test cases covering download, skip, error scenarios
- Remove has at least 3 test cases covering deletion and --now flag
- Tests verify MockRunner method calls where appropriate
- All tests pass without root
  </done>
</task>

<task type="auto">
  <name>Task 3: Test Install operation and run full test suite</name>
  <files>updex/install_test.go</files>
  <action>
**1. Create `updex/install_test.go`:**

Install is complex - it fetches index, downloads transfer file, then calls installTransfer. Use same table-driven pattern as Tasks 1 and 2.

Test cases:
- "installs from repository" - full flow with mocked HTTP
- "component not in index" - returns error
- "transfer file download fails" - returns error

Pattern (following Tasks 1-2 structure):
```go
func TestInstall(t *testing.T) {
    tests := []struct {
        name        string
        setupServer func(*testing.T) *httptest.Server
        component   string
        opts        InstallOptions
        wantErr     bool
        checkResult func(*testing.T, string, *sysext.MockRunner)
    }{...}
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            configDir := t.TempDir()
            targetDir := t.TempDir()
            
            server := tt.setupServer(t)
            defer server.Close()
            
            mockRunner := &sysext.MockRunner{}
            defer sysext.SetRunner(mockRunner)()
            
            // Client config with writable dirs for testing
            client := NewClient(ClientConfig{
                Definitions: configDir,
                // May need Repository field pointing to server.URL
            })
            err := client.Install(context.Background(), tt.component, tt.opts)
            
            if (err != nil) != tt.wantErr {
                t.Errorf("Install() error = %v, wantErr %v", err, tt.wantErr)
            }
            if tt.checkResult != nil {
                tt.checkResult(t, configDir, mockRunner)
            }
        })
    }
}
```

Server setup for Install (serves index + transfer file + extension):
```go
setupServer: func(t *testing.T) *httptest.Server {
    content := []byte("fake extension")
    h := sha256.Sum256(content)
    hash := fmt.Sprintf("%x", h[:])
    
    return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        switch r.URL.Path {
        case "/ext/index":
            w.Write([]byte("myext\notherext\n"))
        case "/ext/myext/myext.transfer":
            // Return valid transfer file content
            fmt.Fprintf(w, `[Source]
Type=url-file
Path=%s/files
MatchPattern=myext_@v.raw

[Target]
MatchPattern=myext_@v.raw
`, server.URL) // Note: need to capture server.URL - may need httptest.NewUnstartedServer pattern
        case "/files/SHA256SUMS":
            fmt.Fprintf(w, "%s  myext_1.0.0.raw\n", hash)
        case "/files/myext_1.0.0.raw":
            w.Write(content)
        default:
            w.WriteHeader(http.StatusNotFound)
        }
    }))
}
```

Note: Install writes to /etc/sysupdate.d by default which needs root. For testing:
1. Override the definitions directory via ClientConfig.Definitions to use t.TempDir()
2. Verify transfer file is written correctly
3. Test that extension file is downloaded

Alternative simpler approach - test installTransfer directly if it's exported, or test validation logic separately.

**2. Run full test suite:**

After creating all tests:
```bash
go test ./... -v
```

Ensure all tests pass without root. Verify with:
```bash
go test ./... -count=1 2>&1 | grep -E "(PASS|FAIL|permission denied)"
```

If any tests require root, they should use `testutil.SkipIfNotRoot(t)` pattern:
```go
func SkipIfNotRoot(t *testing.T) {
    if os.Getuid() != 0 {
        t.Skip("test requires root")
    }
}
```

But prefer mocking over skip - all new tests should work without root.
  </action>
  <verify>
- `go test ./updex/... -run TestInstall` passes
- `go test ./...` passes (full suite)
- All tests run without root privileges
- No tests require network access (all use httptest)
  </verify>
  <done>
- Install has at least 2 test cases (validation, installTransfer)
- Full test suite passes: `go test ./...`
- All core operations have test coverage
- Tests run without root
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `go test ./... -v` - all tests pass
2. Run `go test ./... -count=1` without sudo - no permission errors
3. Verify test coverage for updex package:
   ```bash
   go test ./updex/... -cover
   ```
4. Verify no tests skip or require special setup
</verification>

<success_criteria>
1. MockRunner exists and is used by tests
2. List operation: 3+ test cases, tests pass
3. Check operation: 3+ test cases, tests pass
4. Update operation: 4+ test cases, tests pass
5. Remove operation: 3+ test cases, tests pass
6. Install operation: 2+ test cases, tests pass
7. All tests run without root privileges
8. Full test suite passes: `go test ./...`
</success_criteria>

<output>
After completion, create `.planning/phases/01-test-foundation/01-02-SUMMARY.md`
</output>
