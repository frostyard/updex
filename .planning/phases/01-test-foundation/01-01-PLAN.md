---
phase: 01-test-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/sysext/runner.go
  - internal/sysext/manager.go
  - internal/testutil/httpserver.go
  - updex/updex.go
autonomous: true

must_haves:
  truths:
    - "Tests can mock systemd-sysext commands without executing real binaries"
    - "Tests can create HTTP servers that respond with controlled manifest/file data"
    - "Client accepts a SysextRunner for dependency injection"
  artifacts:
    - path: "internal/sysext/runner.go"
      provides: "SysextRunner interface and DefaultRunner implementation"
      exports: ["SysextRunner", "DefaultRunner", "SetRunner"]
    - path: "internal/testutil/httpserver.go"
      provides: "HTTP test server helper for registry mocking"
      exports: ["NewTestServer"]
    - path: "updex/updex.go"
      provides: "Client with SysextRunner injection"
      contains: "SysextRunner"
  key_links:
    - from: "internal/sysext/manager.go"
      to: "internal/sysext/runner.go"
      via: "uses runner variable"
      pattern: "runner\\.(Refresh|Merge|Unmerge)"
    - from: "updex/updex.go"
      to: "internal/sysext/runner.go"
      via: "ClientConfig.SysextRunner"
      pattern: "SysextRunner"
---

<objective>
Create test infrastructure for mocking systemd commands and HTTP registries.

Purpose: Enable testing of core updex operations without root privileges by abstracting external dependencies behind mockable interfaces.

Output: SysextRunner interface for mocking systemd-sysext, HTTP test helper for registry mocking, Client accepts runner via config.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-test-foundation/01-CONTEXT.md
@.planning/phases/01-test-foundation/01-RESEARCH.md
@internal/sysext/manager.go
@updex/updex.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SysextRunner interface and refactor sysext package</name>
  <files>internal/sysext/runner.go, internal/sysext/manager.go</files>
  <action>
Create `internal/sysext/runner.go` with:

1. SysextRunner interface:
```go
// SysextRunner executes systemd-sysext commands
type SysextRunner interface {
    Refresh() error
    Merge() error
    Unmerge() error
}
```

2. DefaultRunner implementation that executes real systemd-sysext commands (move existing exec.Command logic from manager.go):
```go
// DefaultRunner executes real systemd-sysext commands
type DefaultRunner struct{}

func (r *DefaultRunner) Refresh() error {
    return runSysextCommand("refresh")
}
// ... Merge, Unmerge similarly
```

3. Package-level runner variable with setter for tests:
```go
var runner SysextRunner = &DefaultRunner{}

// SetRunner sets the runner for testing (returns cleanup function)
func SetRunner(r SysextRunner) func() {
    old := runner
    runner = r
    return func() { runner = old }
}
```

4. Update manager.go to use the runner variable:
- Change `Refresh()` to call `return runner.Refresh()`
- Change `Merge()` to call `return runner.Merge()`
- Change `Unmerge()` to call `return runner.Unmerge()`
- Keep `runSysextCommand` as private helper for DefaultRunner

Do NOT change function signatures of public Refresh/Merge/Unmerge - they stay as package-level functions that delegate to the runner.
  </action>
  <verify>
- `go build ./internal/sysext/...` compiles
- `go test ./internal/sysext/...` passes (existing tests still work)
- Confirm runner.go exports SysextRunner, DefaultRunner, SetRunner
  </verify>
  <done>
- SysextRunner interface exists with Refresh, Merge, Unmerge methods
- DefaultRunner implements the interface using exec.Command
- Package-level SetRunner function allows test injection
- Existing sysext tests pass unchanged
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HTTP test server helper</name>
  <files>internal/testutil/httpserver.go</files>
  <action>
Create `internal/testutil/httpserver.go` with helper for creating test HTTP servers that mock registries:

```go
package testutil

import (
    "fmt"
    "net/http"
    "net/http/httptest"
    "strings"
    "testing"
)

// TestServerFiles maps filename to content (for downloads) or filename to hash (for manifest)
type TestServerFiles struct {
    // Files maps filename to SHA256 hash (appears in SHA256SUMS)
    Files map[string]string
    // Content maps filename to file content (for downloads)
    Content map[string][]byte
}

// NewTestServer creates an httptest.Server that serves SHA256SUMS manifest and files.
// The server serves:
//   - /SHA256SUMS - manifest with hash + filename entries
//   - /{filename} - file content from Content map
func NewTestServer(t *testing.T, files TestServerFiles) *httptest.Server {
    t.Helper()
    return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        path := strings.TrimPrefix(r.URL.Path, "/")
        
        if path == "SHA256SUMS" {
            var lines []string
            for filename, hash := range files.Files {
                lines = append(lines, fmt.Sprintf("%s  %s", hash, filename))
            }
            w.Write([]byte(strings.Join(lines, "\n")))
            return
        }
        
        if content, ok := files.Content[path]; ok {
            w.Write(content)
            return
        }
        
        w.WriteHeader(http.StatusNotFound)
    }))
}

// NewErrorServer creates a server that always returns the given status code
func NewErrorServer(t *testing.T, statusCode int) *httptest.Server {
    t.Helper()
    return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(statusCode)
    }))
}
```

This follows patterns from existing tests (manifest_test.go) but provides reusable helpers.
  </action>
  <verify>
- `go build ./internal/testutil/...` compiles
- Package exports NewTestServer and NewErrorServer
  </verify>
  <done>
- testutil package exists with HTTP test server helpers
- NewTestServer creates server serving SHA256SUMS manifest and files
- NewErrorServer creates server for error testing
  </done>
</task>

<task type="auto">
  <name>Task 3: Add SysextRunner to Client config</name>
  <files>updex/updex.go</files>
  <action>
Update `updex/updex.go` to accept SysextRunner in ClientConfig for testability:

1. Add import for internal/sysext package (if not already imported)

2. Add SysextRunner field to ClientConfig:
```go
type ClientConfig struct {
    // ... existing fields ...

    // SysextRunner is an optional runner for systemd-sysext commands.
    // If nil, uses the default runner that executes real commands.
    // Set this in tests to inject a mock.
    SysextRunner sysext.SysextRunner
}
```

3. In NewClient, if SysextRunner is provided, call SetRunner:
```go
func NewClient(cfg ClientConfig) *Client {
    if cfg.SysextRunner != nil {
        sysext.SetRunner(cfg.SysextRunner)
    }
    return &Client{
        config: cfg,
        helper: progress.NewProgressHelper(nil, cfg.Progress),
    }
}
```

This allows tests to inject a mock runner when creating a Client, while production code passes nil and uses the default.

Note: This is a simple approach. The SetRunner call is global, which is fine for tests that don't run in parallel with different runners. For more isolation, tests should call defer sysext.SetRunner(mockRunner)() to restore.
  </action>
  <verify>
- `go build ./updex/...` compiles
- `go build ./cmd/...` compiles (CLI still works)
- ClientConfig has SysextRunner field
  </verify>
  <done>
- ClientConfig accepts optional SysextRunner
- NewClient sets the runner when provided
- Existing code continues to work (nil = default runner)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `go build ./...` - should compile without errors
2. Run `go test ./...` - all existing tests pass
3. Verify exports:
   - `grep -n "type SysextRunner interface" internal/sysext/runner.go`
   - `grep -n "func SetRunner" internal/sysext/runner.go`
   - `grep -n "func NewTestServer" internal/testutil/httpserver.go`
   - `grep -n "SysextRunner" updex/updex.go`
</verification>

<success_criteria>
1. SysextRunner interface exists for mocking systemd commands
2. SetRunner allows test injection of mock runner
3. HTTP test helper exists for registry mocking
4. Client accepts SysextRunner via config
5. All existing tests pass
6. All packages compile
</success_criteria>

<output>
After completion, create `.planning/phases/01-test-foundation/01-01-SUMMARY.md`
</output>
