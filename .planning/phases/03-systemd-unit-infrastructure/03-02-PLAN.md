---
phase: 03-systemd-unit-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/systemd/runner.go
  - internal/systemd/mock_runner.go
autonomous: true

must_haves:
  truths:
    - "SystemctlRunner interface abstracts systemctl command execution"
    - "DefaultSystemctlRunner executes real systemctl commands"
    - "MockSystemctlRunner can be used in tests without root"
    - "Pattern matches existing SysextRunner for consistency"
  artifacts:
    - path: "internal/systemd/runner.go"
      provides: "SystemctlRunner interface and DefaultSystemctlRunner"
      exports: ["SystemctlRunner", "DefaultSystemctlRunner", "SetRunner"]
    - path: "internal/systemd/mock_runner.go"
      provides: "MockSystemctlRunner for testing"
      exports: ["MockSystemctlRunner"]
  key_links:
    - from: "internal/systemd/runner.go"
      to: "os/exec"
      via: "exec.Command for systemctl calls"
      pattern: "exec\\.Command.*systemctl"
---

<objective>
Create the SystemctlRunner interface and implementations for abstracting systemctl command execution, enabling testability without root privileges.

Purpose: Allow Manager to be tested in temp directories without requiring real systemctl calls.
Output: runner.go with interface and default implementation, mock_runner.go with test double.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-systemd-unit-infrastructure/03-RESEARCH.md
@internal/sysext/runner.go (MUST follow this exact pattern)
@internal/sysext/mock_runner.go (MUST follow this exact pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SystemctlRunner interface and DefaultSystemctlRunner</name>
  <files>internal/systemd/runner.go</files>
  <action>
Create runner.go in internal/systemd/ following the EXACT pattern from internal/sysext/runner.go:

1. **SystemctlRunner interface** with methods:
   - DaemonReload() error
   - Enable(unit string) error
   - Disable(unit string) error
   - Start(unit string) error
   - Stop(unit string) error
   - IsActive(unit string) (bool, error)
   - IsEnabled(unit string) (bool, error)

2. **DefaultSystemctlRunner struct** (empty, implements interface)

3. **Implementation of each method:**
   - DaemonReload: exec.Command("systemctl", "daemon-reload")
   - Enable: exec.Command("systemctl", "enable", unit)
   - Disable: exec.Command("systemctl", "disable", unit)
   - Start: exec.Command("systemctl", "start", unit)
   - Stop: exec.Command("systemctl", "stop", unit)
   - IsActive: exec.Command("systemctl", "is-active", unit) - return true if exit code 0
   - IsEnabled: exec.Command("systemctl", "is-enabled", unit) - return true if exit code 0

4. **Package-level runner variable and SetRunner function:**
   - var runner SystemctlRunner = &DefaultSystemctlRunner{}
   - func SetRunner(r SystemctlRunner) func() { ... } - returns cleanup function

5. **Helper function:**
   - func runSystemctl(args ...string) error - wraps exec.Command

Use fmt.Errorf for error wrapping. Follow existing sysext/runner.go exactly for style.
  </action>
  <verify>go build ./internal/systemd/... compiles successfully</verify>
  <done>runner.go exists with SystemctlRunner interface, DefaultSystemctlRunner, and SetRunner function</done>
</task>

<task type="auto">
  <name>Task 2: Create MockSystemctlRunner for testing</name>
  <files>internal/systemd/mock_runner.go</files>
  <action>
Create mock_runner.go following the EXACT pattern from internal/sysext/mock_runner.go:

1. **MockSystemctlRunner struct** with fields for each method:
   - DaemonReloadCalled bool
   - DaemonReloadErr error
   - EnableCalled bool
   - EnableUnit string (captures which unit was enabled)
   - EnableErr error
   - DisableCalled bool
   - DisableUnit string
   - DisableErr error
   - StartCalled bool
   - StartUnit string
   - StartErr error
   - StopCalled bool
   - StopUnit string
   - StopErr error
   - IsActiveCalled bool
   - IsActiveUnit string
   - IsActiveResult bool
   - IsActiveErr error
   - IsEnabledCalled bool
   - IsEnabledUnit string
   - IsEnabledResult bool
   - IsEnabledErr error

2. **Implement all interface methods:**
   - Set Called=true, capture unit name, return configured result/error

No tests needed for mock itself - it will be tested via Manager tests in Plan 03.
  </action>
  <verify>go build ./internal/systemd/... compiles with no errors</verify>
  <done>mock_runner.go exists with MockSystemctlRunner implementing SystemctlRunner interface</done>
</task>

</tasks>

<verification>
```bash
# Package compiles
go build ./internal/systemd/...

# Interface is properly defined (will be tested by Plan 03)
go vet ./internal/systemd/...
```
</verification>

<success_criteria>
1. internal/systemd/runner.go exists with SystemctlRunner interface
2. internal/systemd/mock_runner.go exists with MockSystemctlRunner
3. Package compiles without errors
4. Pattern matches internal/sysext/runner.go and mock_runner.go
</success_criteria>

<output>
After completion, create `.planning/phases/03-systemd-unit-infrastructure/03-02-SUMMARY.md`
</output>
